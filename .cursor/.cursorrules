# Fynlo POS Development Standards & Best Practices

## Core Development Philosophy
- **Defensive Programming**: Always assume things can fail - validate inputs, handle errors, check for null/undefined
- **Production-First Mindset**: Code as if it's already in production - no shortcuts, no "temporary" hacks
- **Multi-Tenant Security**: Every feature must respect restaurant boundaries - no data leakage between tenants
- **Real-Time Reliability**: WebSocket/async operations must handle disconnections, retries, and state recovery
- **Mobile-First Design**: Optimize for React Native constraints and mobile network conditions

## Code Organization & Cleanliness

### File Structure Conventions
```
/feature-name/
  ├── index.ts           # Public exports only
  ├── types.ts           # TypeScript interfaces/types
  ├── constants.ts       # Feature constants
  ├── hooks/             # React hooks
  ├── components/        # React components
  ├── services/          # Business logic
  ├── utils/             # Pure utility functions
  └── __tests__/         # Test files mirror source structure
```

### Import Order (Enforce with ESLint)
1. External packages (React, React Native)
2. Internal packages (@fynlo/shared)
3. Absolute imports (from src/)
4. Relative imports (current feature)
5. Types (import type)
6. Styles/Assets

### Naming Conventions
- **Files**: kebab-case for files, PascalCase for components
- **Variables**: camelCase for variables, UPPER_SNAKE for constants
- **Types**: PascalCase with descriptive suffixes (UserDTO, PaymentRequest, OrderResponse)
- **Hooks**: Always prefix with 'use' (useWebSocket, useAuth)
- **Services**: Suffix with 'Service' (WebSocketService, PaymentService)

## TypeScript Standards

### Type Safety Rules
```typescript
// ❌ BAD - Avoid any and loose typing
const processData = (data: any) => data.value;
const amount = price as number;

// ✅ GOOD - Explicit types and proper guards
const processData = (data: OrderData): string => data.value;
const amount = typeof price === 'number' ? price : 0;
```

### Interface Design
```typescript
// Always define explicit interfaces for:
- API requests/responses
- WebSocket messages
- Component props
- Store state shapes
- Service method parameters

// Use discriminated unions for state machines
type ConnectionState = 
  | { status: 'disconnected' }
  | { status: 'connecting'; attempt: number }
  | { status: 'connected'; sessionId: string }
  | { status: 'error'; error: Error };
```

## Error Handling & Logging

### Error Handling Patterns
```typescript
// Service layer: Return Result types
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

// Component layer: Use error boundaries
// Hook layer: Return error states
// Async operations: Always try-catch
```

### Logging Standards
```typescript
// Use structured logging with context
logger.info('Operation started', { 
  operation: 'createOrder',
  userId: user.id,
  restaurantId: restaurant.id 
});

// Log levels:
// - debug: Development only, verbose details
// - info: Normal operations, state changes
// - warn: Recoverable issues, deprecated usage
// - error: Failures requiring attention
```

## React Native & Frontend

### Component Design
```typescript
// Prefer composition over inheritance
// Use custom hooks for logic extraction
// Keep components under 200 lines
// Separate presentational from container components
```

### Performance Rules
- Memoize expensive computations with useMemo
- Use React.memo for pure components
- Implement FlatList with proper keyExtractor and getItemLayout
- Lazy load screens and heavy components
- Profile with Flipper before optimizing

### State Management
```typescript
// Zustand stores for:
- Global app state (auth, user, restaurant)
- Feature state (cart, orders, inventory)
- UI state (modals, navigation)

// Local state for:
- Form inputs
- UI toggles
- Component-specific data
```

## Backend (Python/FastAPI)

### API Design
```python
# All endpoints must:
# - Use FynloException for errors
# - Return APIResponseHelper responses
# - Include restaurant_id validation
# - Have proper Pydantic models
# - Include comprehensive docstrings

@router.post("/orders", response_model=OrderResponse)
async def create_order(
    request: OrderCreateRequest,
    restaurant_id: UUID = Depends(validate_restaurant),
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
) -> APIResponse:
    """
    Create a new order for the restaurant.
    
    Validates:
    - User has permission for restaurant
    - Products exist and are available
    - Pricing calculations are correct
    """
```

### Database Patterns
```python
# Always use:
# - DECIMAL for money (never float)
# - UUID for IDs
# - Soft deletes (is_active flags)
# - Audit fields (created_at, updated_by)
# - Proper indexes for queries
# - Database transactions for multi-table updates
```

## WebSocket & Real-Time

### Connection Management
- Implement exponential backoff for reconnections
- Clean up event listeners on disconnect
- Handle authentication via message AND URL params
- Support graceful degradation when WebSocket unavailable
- Implement heartbeat/ping-pong for connection health

### Message Protocol
```typescript
interface WebSocketMessage {
  id: string;           // Unique message ID
  type: string;         // Event type
  data: unknown;        // Payload
  timestamp: string;    // ISO timestamp
  restaurant_id: string; // Tenant isolation
}
```

## Testing Standards

### Test Coverage Requirements
- Frontend: 70% minimum, 90% for critical paths
- Backend: 80% minimum, 100% for payment/auth
- Integration tests for all API endpoints
- E2E tests for critical user journeys

### Test Organization
```typescript
describe('ServiceName', () => {
  describe('methodName', () => {
    it('should handle success case', () => {});
    it('should handle error case', () => {});
    it('should validate inputs', () => {});
    it('should respect tenant boundaries', () => {});
  });
});
```

## MCP Server Development

### Creating New MCP Servers
```bash
# Location: /Users/arnauddecube/.config/claude/mcps/
# Structure:
server-name/
  ├── package.json
  ├── tsconfig.json
  ├── src/
  │   ├── index.ts      # Server entry point
  │   ├── tools/        # Tool implementations
  │   └── types.ts      # TypeScript definitions
  └── dist/             # Compiled output
```

### MCP Server Standards
- Each tool should have single responsibility
- Implement proper error handling and retries
- Return structured, typed responses
- Include comprehensive tool descriptions
- Log operations for debugging
- Handle rate limiting gracefully

## Security Checklist (Every PR)

### Authentication & Authorization
- [ ] Verify all endpoints check authentication
- [ ] Validate role-based permissions
- [ ] Ensure restaurant_id isolation
- [ ] Check token expiration handling

### Input Validation
- [ ] Sanitize all user inputs
- [ ] Validate UUIDs and IDs
- [ ] Check numeric bounds
- [ ] Prevent SQL injection
- [ ] Validate file uploads

### Data Protection
- [ ] No sensitive data in logs
- [ ] Mask tokens in debug output
- [ ] Use HTTPS only
- [ ] Implement rate limiting
- [ ] Audit data access

## Git & Collaboration

### Branch Naming
- `fix/description` - Bug fixes
- `feat/description` - New features
- `refactor/description` - Code improvements
- `docs/description` - Documentation
- `test/description` - Test additions

### Commit Messages
```
type(scope): description

- Bullet points for details
- Reference issue numbers
- Explain why, not just what

Co-Authored-By: Name <email>
```

### PR Process
1. Create from feature branch
2. Fill template completely
3. Wait for CI checks
4. Address review comments in same PR
5. Squash merge when approved

## Performance Guidelines

### Database Queries
- Use select_related/prefetch_related
- Implement pagination (limit 100)
- Add database indexes for WHERE clauses
- Cache frequent queries in Redis
- Monitor slow query logs

### API Response Times
- Target: < 200ms for queries
- Target: < 500ms for mutations
- Use async operations
- Implement request caching
- Profile with DataDog/NewRelic

### Mobile Performance
- Bundle size < 10MB
- Cold start < 3 seconds
- FPS > 55 for animations
- Memory usage < 200MB
- Network requests batched

## Documentation Standards

### Code Documentation
- Every public method needs docstring
- Complex logic needs inline comments
- Type definitions for all parameters
- Example usage for utilities
- README in each major directory

### API Documentation
- OpenAPI/Swagger specs
- Request/response examples
- Error code definitions
- Rate limit information
- Authentication requirements

## Monitoring & Observability

### Required Instrumentation
- Structured logging (JSON)
- Distributed tracing (OpenTelemetry)
- Error tracking (Sentry)
- Performance monitoring (DataDog)
- Business metrics (Mixpanel)

### Alert Conditions
- API error rate > 1%
- Response time > 1s
- WebSocket disconnection rate > 5%
- Payment failure rate > 2%
- Database connection pool exhaustion

## Code Review Checklist

Before submitting PR:
- [ ] Tests pass locally
- [ ] No console.log statements
- [ ] Error handling complete
- [ ] Types properly defined
- [ ] Security checklist complete
- [ ] Documentation updated
- [ ] Performance impact considered
- [ ] Multi-tenant isolation verified

## Refactoring Rules

When refactoring:
1. One refactor type per PR
2. Maintain backward compatibility
3. Update tests first (TDD)
4. Document breaking changes
5. Coordinate with team for large changes
6. Performance test before/after
7. Keep PRs under 500 lines

## Dependencies

### Adding New Packages
- Justify need in PR description
- Check license compatibility
- Review security advisories
- Consider bundle size impact
- Update lock files properly
- Document in README

### Version Management
- Pin exact versions in production
- Regular dependency updates (monthly)
- Test thoroughly after updates
- Keep React Native versions in sync
- Document upgrade procedures